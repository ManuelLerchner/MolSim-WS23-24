// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "simulation_schema.h"

#include <xsd/cxx/pre.hxx>

// DoubleVec3Type
//

const DoubleVec3Type::x_type& DoubleVec3Type::x() const { return this->x_.get(); }

DoubleVec3Type::x_type& DoubleVec3Type::x() { return this->x_.get(); }

void DoubleVec3Type::x(const x_type& x) { this->x_.set(x); }

const DoubleVec3Type::y_type& DoubleVec3Type::y() const { return this->y_.get(); }

DoubleVec3Type::y_type& DoubleVec3Type::y() { return this->y_.get(); }

void DoubleVec3Type::y(const y_type& x) { this->y_.set(x); }

const DoubleVec3Type::z_type& DoubleVec3Type::z() const { return this->z_.get(); }

DoubleVec3Type::z_type& DoubleVec3Type::z() { return this->z_.get(); }

void DoubleVec3Type::z(const z_type& x) { this->z_.set(x); }

// IntVec3Type
//

const IntVec3Type::x_type& IntVec3Type::x() const { return this->x_.get(); }

IntVec3Type::x_type& IntVec3Type::x() { return this->x_.get(); }

void IntVec3Type::x(const x_type& x) { this->x_.set(x); }

const IntVec3Type::y_type& IntVec3Type::y() const { return this->y_.get(); }

IntVec3Type::y_type& IntVec3Type::y() { return this->y_.get(); }

void IntVec3Type::y(const y_type& x) { this->y_.set(x); }

const IntVec3Type::z_type& IntVec3Type::z() const { return this->z_.get(); }

IntVec3Type::z_type& IntVec3Type::z() { return this->z_.get(); }

void IntVec3Type::z(const z_type& x) { this->z_.set(x); }

// ParticleContainerType
//

const ParticleContainerType::directsum_container_optional& ParticleContainerType::directsum_container() const {
    return this->directsum_container_;
}

ParticleContainerType::directsum_container_optional& ParticleContainerType::directsum_container() { return this->directsum_container_; }

void ParticleContainerType::directsum_container(const directsum_container_type& x) { this->directsum_container_.set(x); }

void ParticleContainerType::directsum_container(const directsum_container_optional& x) { this->directsum_container_ = x; }

void ParticleContainerType::directsum_container(::std::unique_ptr<directsum_container_type> x) {
    this->directsum_container_.set(std::move(x));
}

const ParticleContainerType::linkedcells_container_optional& ParticleContainerType::linkedcells_container() const {
    return this->linkedcells_container_;
}

ParticleContainerType::linkedcells_container_optional& ParticleContainerType::linkedcells_container() {
    return this->linkedcells_container_;
}

void ParticleContainerType::linkedcells_container(const linkedcells_container_type& x) { this->linkedcells_container_.set(x); }

void ParticleContainerType::linkedcells_container(const linkedcells_container_optional& x) { this->linkedcells_container_ = x; }

void ParticleContainerType::linkedcells_container(::std::unique_ptr<linkedcells_container_type> x) {
    this->linkedcells_container_.set(std::move(x));
}

// DirectSumContainerType
//

// LinkedCellsContainerType
//

const LinkedCellsContainerType::domain_size_type& LinkedCellsContainerType::domain_size() const { return this->domain_size_.get(); }

LinkedCellsContainerType::domain_size_type& LinkedCellsContainerType::domain_size() { return this->domain_size_.get(); }

void LinkedCellsContainerType::domain_size(const domain_size_type& x) { this->domain_size_.set(x); }

void LinkedCellsContainerType::domain_size(::std::unique_ptr<domain_size_type> x) { this->domain_size_.set(std::move(x)); }

const LinkedCellsContainerType::cutoff_radius_type& LinkedCellsContainerType::cutoff_radius() const { return this->cutoff_radius_.get(); }

LinkedCellsContainerType::cutoff_radius_type& LinkedCellsContainerType::cutoff_radius() { return this->cutoff_radius_.get(); }

void LinkedCellsContainerType::cutoff_radius(const cutoff_radius_type& x) { this->cutoff_radius_.set(x); }

const LinkedCellsContainerType::boundary_conditions_type& LinkedCellsContainerType::boundary_conditions() const {
    return this->boundary_conditions_.get();
}

LinkedCellsContainerType::boundary_conditions_type& LinkedCellsContainerType::boundary_conditions() {
    return this->boundary_conditions_.get();
}

void LinkedCellsContainerType::boundary_conditions(const boundary_conditions_type& x) { this->boundary_conditions_.set(x); }

void LinkedCellsContainerType::boundary_conditions(::std::unique_ptr<boundary_conditions_type> x) {
    this->boundary_conditions_.set(std::move(x));
}

// BoundaryConditionsType
//

const BoundaryConditionsType::left_type& BoundaryConditionsType::left() const { return this->left_.get(); }

BoundaryConditionsType::left_type& BoundaryConditionsType::left() { return this->left_.get(); }

void BoundaryConditionsType::left(const left_type& x) { this->left_.set(x); }

void BoundaryConditionsType::left(::std::unique_ptr<left_type> x) { this->left_.set(std::move(x)); }

const BoundaryConditionsType::right_type& BoundaryConditionsType::right() const { return this->right_.get(); }

BoundaryConditionsType::right_type& BoundaryConditionsType::right() { return this->right_.get(); }

void BoundaryConditionsType::right(const right_type& x) { this->right_.set(x); }

void BoundaryConditionsType::right(::std::unique_ptr<right_type> x) { this->right_.set(std::move(x)); }

const BoundaryConditionsType::bottom_type& BoundaryConditionsType::bottom() const { return this->bottom_.get(); }

BoundaryConditionsType::bottom_type& BoundaryConditionsType::bottom() { return this->bottom_.get(); }

void BoundaryConditionsType::bottom(const bottom_type& x) { this->bottom_.set(x); }

void BoundaryConditionsType::bottom(::std::unique_ptr<bottom_type> x) { this->bottom_.set(std::move(x)); }

const BoundaryConditionsType::top_type& BoundaryConditionsType::top() const { return this->top_.get(); }

BoundaryConditionsType::top_type& BoundaryConditionsType::top() { return this->top_.get(); }

void BoundaryConditionsType::top(const top_type& x) { this->top_.set(x); }

void BoundaryConditionsType::top(::std::unique_ptr<top_type> x) { this->top_.set(std::move(x)); }

const BoundaryConditionsType::back_type& BoundaryConditionsType::back() const { return this->back_.get(); }

BoundaryConditionsType::back_type& BoundaryConditionsType::back() { return this->back_.get(); }

void BoundaryConditionsType::back(const back_type& x) { this->back_.set(x); }

void BoundaryConditionsType::back(::std::unique_ptr<back_type> x) { this->back_.set(std::move(x)); }

const BoundaryConditionsType::front_type& BoundaryConditionsType::front() const { return this->front_.get(); }

BoundaryConditionsType::front_type& BoundaryConditionsType::front() { return this->front_.get(); }

void BoundaryConditionsType::front(const front_type& x) { this->front_.set(x); }

void BoundaryConditionsType::front(::std::unique_ptr<front_type> x) { this->front_.set(std::move(x)); }

// BoundaryType
//

const BoundaryType::outflow_optional& BoundaryType::outflow() const { return this->outflow_; }

BoundaryType::outflow_optional& BoundaryType::outflow() { return this->outflow_; }

void BoundaryType::outflow(const outflow_type& x) { this->outflow_.set(x); }

void BoundaryType::outflow(const outflow_optional& x) { this->outflow_ = x; }

void BoundaryType::outflow(::std::unique_ptr<outflow_type> x) { this->outflow_.set(std::move(x)); }

const BoundaryType::reflective_optional& BoundaryType::reflective() const { return this->reflective_; }

BoundaryType::reflective_optional& BoundaryType::reflective() { return this->reflective_; }

void BoundaryType::reflective(const reflective_type& x) { this->reflective_.set(x); }

void BoundaryType::reflective(const reflective_optional& x) { this->reflective_ = x; }

void BoundaryType::reflective(::std::unique_ptr<reflective_type> x) { this->reflective_.set(std::move(x)); }

// OutflowBoundaryType
//

// ReflectiveBoundaryType
//

// CuboidSpawnerType
//

const CuboidSpawnerType::lower_left_front_corner_type& CuboidSpawnerType::lower_left_front_corner() const {
    return this->lower_left_front_corner_.get();
}

CuboidSpawnerType::lower_left_front_corner_type& CuboidSpawnerType::lower_left_front_corner() {
    return this->lower_left_front_corner_.get();
}

void CuboidSpawnerType::lower_left_front_corner(const lower_left_front_corner_type& x) { this->lower_left_front_corner_.set(x); }

void CuboidSpawnerType::lower_left_front_corner(::std::unique_ptr<lower_left_front_corner_type> x) {
    this->lower_left_front_corner_.set(std::move(x));
}

const CuboidSpawnerType::grid_dim_type& CuboidSpawnerType::grid_dim() const { return this->grid_dim_.get(); }

CuboidSpawnerType::grid_dim_type& CuboidSpawnerType::grid_dim() { return this->grid_dim_.get(); }

void CuboidSpawnerType::grid_dim(const grid_dim_type& x) { this->grid_dim_.set(x); }

void CuboidSpawnerType::grid_dim(::std::unique_ptr<grid_dim_type> x) { this->grid_dim_.set(std::move(x)); }

const CuboidSpawnerType::grid_spacing_type& CuboidSpawnerType::grid_spacing() const { return this->grid_spacing_.get(); }

CuboidSpawnerType::grid_spacing_type& CuboidSpawnerType::grid_spacing() { return this->grid_spacing_.get(); }

void CuboidSpawnerType::grid_spacing(const grid_spacing_type& x) { this->grid_spacing_.set(x); }

const CuboidSpawnerType::temperature_type& CuboidSpawnerType::temperature() const { return this->temperature_.get(); }

CuboidSpawnerType::temperature_type& CuboidSpawnerType::temperature() { return this->temperature_.get(); }

void CuboidSpawnerType::temperature(const temperature_type& x) { this->temperature_.set(x); }

const CuboidSpawnerType::mass_type& CuboidSpawnerType::mass() const { return this->mass_.get(); }

CuboidSpawnerType::mass_type& CuboidSpawnerType::mass() { return this->mass_.get(); }

void CuboidSpawnerType::mass(const mass_type& x) { this->mass_.set(x); }

const CuboidSpawnerType::velocity_type& CuboidSpawnerType::velocity() const { return this->velocity_.get(); }

CuboidSpawnerType::velocity_type& CuboidSpawnerType::velocity() { return this->velocity_.get(); }

void CuboidSpawnerType::velocity(const velocity_type& x) { this->velocity_.set(x); }

void CuboidSpawnerType::velocity(::std::unique_ptr<velocity_type> x) { this->velocity_.set(std::move(x)); }

const CuboidSpawnerType::type_type& CuboidSpawnerType::type() const { return this->type_.get(); }

CuboidSpawnerType::type_type& CuboidSpawnerType::type() { return this->type_.get(); }

void CuboidSpawnerType::type(const type_type& x) { this->type_.set(x); }

// SphereSpawnerType
//

const SphereSpawnerType::center_type& SphereSpawnerType::center() const { return this->center_.get(); }

SphereSpawnerType::center_type& SphereSpawnerType::center() { return this->center_.get(); }

void SphereSpawnerType::center(const center_type& x) { this->center_.set(x); }

void SphereSpawnerType::center(::std::unique_ptr<center_type> x) { this->center_.set(std::move(x)); }

const SphereSpawnerType::radius_type& SphereSpawnerType::radius() const { return this->radius_.get(); }

SphereSpawnerType::radius_type& SphereSpawnerType::radius() { return this->radius_.get(); }

void SphereSpawnerType::radius(const radius_type& x) { this->radius_.set(x); }

const SphereSpawnerType::grid_spacing_type& SphereSpawnerType::grid_spacing() const { return this->grid_spacing_.get(); }

SphereSpawnerType::grid_spacing_type& SphereSpawnerType::grid_spacing() { return this->grid_spacing_.get(); }

void SphereSpawnerType::grid_spacing(const grid_spacing_type& x) { this->grid_spacing_.set(x); }

const SphereSpawnerType::temperature_type& SphereSpawnerType::temperature() const { return this->temperature_.get(); }

SphereSpawnerType::temperature_type& SphereSpawnerType::temperature() { return this->temperature_.get(); }

void SphereSpawnerType::temperature(const temperature_type& x) { this->temperature_.set(x); }

const SphereSpawnerType::mass_type& SphereSpawnerType::mass() const { return this->mass_.get(); }

SphereSpawnerType::mass_type& SphereSpawnerType::mass() { return this->mass_.get(); }

void SphereSpawnerType::mass(const mass_type& x) { this->mass_.set(x); }

const SphereSpawnerType::velocity_type& SphereSpawnerType::velocity() const { return this->velocity_.get(); }

SphereSpawnerType::velocity_type& SphereSpawnerType::velocity() { return this->velocity_.get(); }

void SphereSpawnerType::velocity(const velocity_type& x) { this->velocity_.set(x); }

void SphereSpawnerType::velocity(::std::unique_ptr<velocity_type> x) { this->velocity_.set(std::move(x)); }

const SphereSpawnerType::type_type& SphereSpawnerType::type() const { return this->type_.get(); }

SphereSpawnerType::type_type& SphereSpawnerType::type() { return this->type_.get(); }

void SphereSpawnerType::type(const type_type& x) { this->type_.set(x); }

// ParticleType
//

const ParticleType::position_type& ParticleType::position() const { return this->position_.get(); }

ParticleType::position_type& ParticleType::position() { return this->position_.get(); }

void ParticleType::position(const position_type& x) { this->position_.set(x); }

void ParticleType::position(::std::unique_ptr<position_type> x) { this->position_.set(std::move(x)); }

const ParticleType::temperature_type& ParticleType::temperature() const { return this->temperature_.get(); }

ParticleType::temperature_type& ParticleType::temperature() { return this->temperature_.get(); }

void ParticleType::temperature(const temperature_type& x) { this->temperature_.set(x); }

const ParticleType::mass_type& ParticleType::mass() const { return this->mass_.get(); }

ParticleType::mass_type& ParticleType::mass() { return this->mass_.get(); }

void ParticleType::mass(const mass_type& x) { this->mass_.set(x); }

const ParticleType::velocity_type& ParticleType::velocity() const { return this->velocity_.get(); }

ParticleType::velocity_type& ParticleType::velocity() { return this->velocity_.get(); }

void ParticleType::velocity(const velocity_type& x) { this->velocity_.set(x); }

void ParticleType::velocity(::std::unique_ptr<velocity_type> x) { this->velocity_.set(std::move(x)); }

const ParticleType::type_type& ParticleType::type() const { return this->type_.get(); }

ParticleType::type_type& ParticleType::type() { return this->type_.get(); }

void ParticleType::type(const type_type& x) { this->type_.set(x); }

// configuration
//

const configuration::settings_type& configuration::settings() const { return this->settings_.get(); }

configuration::settings_type& configuration::settings() { return this->settings_.get(); }

void configuration::settings(const settings_type& x) { this->settings_.set(x); }

void configuration::settings(::std::unique_ptr<settings_type> x) { this->settings_.set(std::move(x)); }

const configuration::particles_type& configuration::particles() const { return this->particles_.get(); }

configuration::particles_type& configuration::particles() { return this->particles_.get(); }

void configuration::particles(const particles_type& x) { this->particles_.set(x); }

void configuration::particles(::std::unique_ptr<particles_type> x) { this->particles_.set(std::move(x)); }

// settings
//

const settings::fps_type& settings::fps() const { return this->fps_.get(); }

settings::fps_type& settings::fps() { return this->fps_.get(); }

void settings::fps(const fps_type& x) { this->fps_.set(x); }

const settings::video_length_type& settings::video_length() const { return this->video_length_.get(); }

settings::video_length_type& settings::video_length() { return this->video_length_.get(); }

void settings::video_length(const video_length_type& x) { this->video_length_.set(x); }

const settings::delta_t_type& settings::delta_t() const { return this->delta_t_.get(); }

settings::delta_t_type& settings::delta_t() { return this->delta_t_.get(); }

void settings::delta_t(const delta_t_type& x) { this->delta_t_.set(x); }

const settings::end_time_type& settings::end_time() const { return this->end_time_.get(); }

settings::end_time_type& settings::end_time() { return this->end_time_.get(); }

void settings::end_time(const end_time_type& x) { this->end_time_.set(x); }

const settings::third_dimension_type& settings::third_dimension() const { return this->third_dimension_.get(); }

settings::third_dimension_type& settings::third_dimension() { return this->third_dimension_.get(); }

void settings::third_dimension(const third_dimension_type& x) { this->third_dimension_.set(x); }

const settings::particle_container_type& settings::particle_container() const { return this->particle_container_.get(); }

settings::particle_container_type& settings::particle_container() { return this->particle_container_.get(); }

void settings::particle_container(const particle_container_type& x) { this->particle_container_.set(x); }

void settings::particle_container(::std::unique_ptr<particle_container_type> x) { this->particle_container_.set(std::move(x)); }

// particles
//

const particles::cuboid_spawner_sequence& particles::cuboid_spawner() const { return this->cuboid_spawner_; }

particles::cuboid_spawner_sequence& particles::cuboid_spawner() { return this->cuboid_spawner_; }

void particles::cuboid_spawner(const cuboid_spawner_sequence& s) { this->cuboid_spawner_ = s; }

const particles::sphere_spawner_sequence& particles::sphere_spawner() const { return this->sphere_spawner_; }

particles::sphere_spawner_sequence& particles::sphere_spawner() { return this->sphere_spawner_; }

void particles::sphere_spawner(const sphere_spawner_sequence& s) { this->sphere_spawner_ = s; }

const particles::single_particle_sequence& particles::single_particle() const { return this->single_particle_; }

particles::single_particle_sequence& particles::single_particle() { return this->single_particle_; }

void particles::single_particle(const single_particle_sequence& s) { this->single_particle_ = s; }

#include <xsd/cxx/xml/dom/parsing-source.hxx>

// DoubleVec3Type
//

DoubleVec3Type::DoubleVec3Type(const x_type& x, const y_type& y, const z_type& z)
    : ::xml_schema::type(), x_(x, this), y_(y, this), z_(z, this) {}

DoubleVec3Type::DoubleVec3Type(const DoubleVec3Type& x, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c), x_(x.x_, f, this), y_(x.y_, f, this), z_(x.z_, f, this) {}

DoubleVec3Type::DoubleVec3Type(const ::xercesc::DOMElement& e, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), x_(this), y_(this), z_(this) {
    if ((f & ::xml_schema::flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void DoubleVec3Type::parse(::xsd::cxx::xml::dom::parser<char>& p, ::xml_schema::flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // x
        //
        if (n.name() == "x" && n.namespace_().empty()) {
            if (!x_.present()) {
                this->x_.set(x_traits::create(i, f, this));
                continue;
            }
        }

        // y
        //
        if (n.name() == "y" && n.namespace_().empty()) {
            if (!y_.present()) {
                this->y_.set(y_traits::create(i, f, this));
                continue;
            }
        }

        // z
        //
        if (n.name() == "z" && n.namespace_().empty()) {
            if (!z_.present()) {
                this->z_.set(z_traits::create(i, f, this));
                continue;
            }
        }

        break;
    }

    if (!x_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("x", "");
    }

    if (!y_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("y", "");
    }

    if (!z_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("z", "");
    }
}

DoubleVec3Type* DoubleVec3Type::_clone(::xml_schema::flags f, ::xml_schema::container* c) const {
    return new class DoubleVec3Type(*this, f, c);
}

DoubleVec3Type& DoubleVec3Type::operator=(const DoubleVec3Type& x) {
    if (this != &x) {
        static_cast< ::xml_schema::type&>(*this) = x;
        this->x_ = x.x_;
        this->y_ = x.y_;
        this->z_ = x.z_;
    }

    return *this;
}

DoubleVec3Type::~DoubleVec3Type() {}

// IntVec3Type
//

IntVec3Type::IntVec3Type(const x_type& x, const y_type& y, const z_type& z) : ::xml_schema::type(), x_(x, this), y_(y, this), z_(z, this) {}

IntVec3Type::IntVec3Type(const IntVec3Type& x, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c), x_(x.x_, f, this), y_(x.y_, f, this), z_(x.z_, f, this) {}

IntVec3Type::IntVec3Type(const ::xercesc::DOMElement& e, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), x_(this), y_(this), z_(this) {
    if ((f & ::xml_schema::flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void IntVec3Type::parse(::xsd::cxx::xml::dom::parser<char>& p, ::xml_schema::flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // x
        //
        if (n.name() == "x" && n.namespace_().empty()) {
            if (!x_.present()) {
                this->x_.set(x_traits::create(i, f, this));
                continue;
            }
        }

        // y
        //
        if (n.name() == "y" && n.namespace_().empty()) {
            if (!y_.present()) {
                this->y_.set(y_traits::create(i, f, this));
                continue;
            }
        }

        // z
        //
        if (n.name() == "z" && n.namespace_().empty()) {
            if (!z_.present()) {
                this->z_.set(z_traits::create(i, f, this));
                continue;
            }
        }

        break;
    }

    if (!x_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("x", "");
    }

    if (!y_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("y", "");
    }

    if (!z_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("z", "");
    }
}

IntVec3Type* IntVec3Type::_clone(::xml_schema::flags f, ::xml_schema::container* c) const { return new class IntVec3Type(*this, f, c); }

IntVec3Type& IntVec3Type::operator=(const IntVec3Type& x) {
    if (this != &x) {
        static_cast< ::xml_schema::type&>(*this) = x;
        this->x_ = x.x_;
        this->y_ = x.y_;
        this->z_ = x.z_;
    }

    return *this;
}

IntVec3Type::~IntVec3Type() {}

// ParticleContainerType
//

ParticleContainerType::ParticleContainerType() : ::xml_schema::type(), directsum_container_(this), linkedcells_container_(this) {}

ParticleContainerType::ParticleContainerType(const ParticleContainerType& x, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      directsum_container_(x.directsum_container_, f, this),
      linkedcells_container_(x.linkedcells_container_, f, this) {}

ParticleContainerType::ParticleContainerType(const ::xercesc::DOMElement& e, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), directsum_container_(this), linkedcells_container_(this) {
    if ((f & ::xml_schema::flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void ParticleContainerType::parse(::xsd::cxx::xml::dom::parser<char>& p, ::xml_schema::flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // directsum_container
        //
        if (n.name() == "directsum_container" && n.namespace_().empty()) {
            ::std::unique_ptr<directsum_container_type> r(directsum_container_traits::create(i, f, this));

            if (!this->directsum_container_) {
                this->directsum_container_.set(::std::move(r));
                continue;
            }
        }

        // linkedcells_container
        //
        if (n.name() == "linkedcells_container" && n.namespace_().empty()) {
            ::std::unique_ptr<linkedcells_container_type> r(linkedcells_container_traits::create(i, f, this));

            if (!this->linkedcells_container_) {
                this->linkedcells_container_.set(::std::move(r));
                continue;
            }
        }

        break;
    }
}

ParticleContainerType* ParticleContainerType::_clone(::xml_schema::flags f, ::xml_schema::container* c) const {
    return new class ParticleContainerType(*this, f, c);
}

ParticleContainerType& ParticleContainerType::operator=(const ParticleContainerType& x) {
    if (this != &x) {
        static_cast< ::xml_schema::type&>(*this) = x;
        this->directsum_container_ = x.directsum_container_;
        this->linkedcells_container_ = x.linkedcells_container_;
    }

    return *this;
}

ParticleContainerType::~ParticleContainerType() {}

// DirectSumContainerType
//

DirectSumContainerType::DirectSumContainerType() : ::xml_schema::type() {}

DirectSumContainerType::DirectSumContainerType(const DirectSumContainerType& x, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c) {}

DirectSumContainerType::DirectSumContainerType(const ::xercesc::DOMElement& e, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f, c) {}

DirectSumContainerType::DirectSumContainerType(const ::xercesc::DOMAttr& a, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(a, f, c) {}

DirectSumContainerType::DirectSumContainerType(const ::std::string& s, const ::xercesc::DOMElement* e, ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type(s, e, f, c) {}

DirectSumContainerType* DirectSumContainerType::_clone(::xml_schema::flags f, ::xml_schema::container* c) const {
    return new class DirectSumContainerType(*this, f, c);
}

DirectSumContainerType::~DirectSumContainerType() {}

// LinkedCellsContainerType
//

LinkedCellsContainerType::LinkedCellsContainerType(const domain_size_type& domain_size, const cutoff_radius_type& cutoff_radius,
                                                   const boundary_conditions_type& boundary_conditions)
    : ::xml_schema::type(),
      domain_size_(domain_size, this),
      cutoff_radius_(cutoff_radius, this),
      boundary_conditions_(boundary_conditions, this) {}

LinkedCellsContainerType::LinkedCellsContainerType(::std::unique_ptr<domain_size_type> domain_size, const cutoff_radius_type& cutoff_radius,
                                                   ::std::unique_ptr<boundary_conditions_type> boundary_conditions)
    : ::xml_schema::type(),
      domain_size_(std::move(domain_size), this),
      cutoff_radius_(cutoff_radius, this),
      boundary_conditions_(std::move(boundary_conditions), this) {}

LinkedCellsContainerType::LinkedCellsContainerType(const LinkedCellsContainerType& x, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      domain_size_(x.domain_size_, f, this),
      cutoff_radius_(x.cutoff_radius_, f, this),
      boundary_conditions_(x.boundary_conditions_, f, this) {}

LinkedCellsContainerType::LinkedCellsContainerType(const ::xercesc::DOMElement& e, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), domain_size_(this), cutoff_radius_(this), boundary_conditions_(this) {
    if ((f & ::xml_schema::flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void LinkedCellsContainerType::parse(::xsd::cxx::xml::dom::parser<char>& p, ::xml_schema::flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // domain_size
        //
        if (n.name() == "domain_size" && n.namespace_().empty()) {
            ::std::unique_ptr<domain_size_type> r(domain_size_traits::create(i, f, this));

            if (!domain_size_.present()) {
                this->domain_size_.set(::std::move(r));
                continue;
            }
        }

        // cutoff_radius
        //
        if (n.name() == "cutoff_radius" && n.namespace_().empty()) {
            if (!cutoff_radius_.present()) {
                this->cutoff_radius_.set(cutoff_radius_traits::create(i, f, this));
                continue;
            }
        }

        // boundary_conditions
        //
        if (n.name() == "boundary_conditions" && n.namespace_().empty()) {
            ::std::unique_ptr<boundary_conditions_type> r(boundary_conditions_traits::create(i, f, this));

            if (!boundary_conditions_.present()) {
                this->boundary_conditions_.set(::std::move(r));
                continue;
            }
        }

        break;
    }

    if (!domain_size_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("domain_size", "");
    }

    if (!cutoff_radius_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("cutoff_radius", "");
    }

    if (!boundary_conditions_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("boundary_conditions", "");
    }
}

LinkedCellsContainerType* LinkedCellsContainerType::_clone(::xml_schema::flags f, ::xml_schema::container* c) const {
    return new class LinkedCellsContainerType(*this, f, c);
}

LinkedCellsContainerType& LinkedCellsContainerType::operator=(const LinkedCellsContainerType& x) {
    if (this != &x) {
        static_cast< ::xml_schema::type&>(*this) = x;
        this->domain_size_ = x.domain_size_;
        this->cutoff_radius_ = x.cutoff_radius_;
        this->boundary_conditions_ = x.boundary_conditions_;
    }

    return *this;
}

LinkedCellsContainerType::~LinkedCellsContainerType() {}

// BoundaryConditionsType
//

BoundaryConditionsType::BoundaryConditionsType(const left_type& left, const right_type& right, const bottom_type& bottom,
                                               const top_type& top, const back_type& back, const front_type& front)
    : ::xml_schema::type(),
      left_(left, this),
      right_(right, this),
      bottom_(bottom, this),
      top_(top, this),
      back_(back, this),
      front_(front, this) {}

BoundaryConditionsType::BoundaryConditionsType(::std::unique_ptr<left_type> left, ::std::unique_ptr<right_type> right,
                                               ::std::unique_ptr<bottom_type> bottom, ::std::unique_ptr<top_type> top,
                                               ::std::unique_ptr<back_type> back, ::std::unique_ptr<front_type> front)
    : ::xml_schema::type(),
      left_(std::move(left), this),
      right_(std::move(right), this),
      bottom_(std::move(bottom), this),
      top_(std::move(top), this),
      back_(std::move(back), this),
      front_(std::move(front), this) {}

BoundaryConditionsType::BoundaryConditionsType(const BoundaryConditionsType& x, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      left_(x.left_, f, this),
      right_(x.right_, f, this),
      bottom_(x.bottom_, f, this),
      top_(x.top_, f, this),
      back_(x.back_, f, this),
      front_(x.front_, f, this) {}

BoundaryConditionsType::BoundaryConditionsType(const ::xercesc::DOMElement& e, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      left_(this),
      right_(this),
      bottom_(this),
      top_(this),
      back_(this),
      front_(this) {
    if ((f & ::xml_schema::flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void BoundaryConditionsType::parse(::xsd::cxx::xml::dom::parser<char>& p, ::xml_schema::flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // left
        //
        if (n.name() == "left" && n.namespace_().empty()) {
            ::std::unique_ptr<left_type> r(left_traits::create(i, f, this));

            if (!left_.present()) {
                this->left_.set(::std::move(r));
                continue;
            }
        }

        // right
        //
        if (n.name() == "right" && n.namespace_().empty()) {
            ::std::unique_ptr<right_type> r(right_traits::create(i, f, this));

            if (!right_.present()) {
                this->right_.set(::std::move(r));
                continue;
            }
        }

        // bottom
        //
        if (n.name() == "bottom" && n.namespace_().empty()) {
            ::std::unique_ptr<bottom_type> r(bottom_traits::create(i, f, this));

            if (!bottom_.present()) {
                this->bottom_.set(::std::move(r));
                continue;
            }
        }

        // top
        //
        if (n.name() == "top" && n.namespace_().empty()) {
            ::std::unique_ptr<top_type> r(top_traits::create(i, f, this));

            if (!top_.present()) {
                this->top_.set(::std::move(r));
                continue;
            }
        }

        // back
        //
        if (n.name() == "back" && n.namespace_().empty()) {
            ::std::unique_ptr<back_type> r(back_traits::create(i, f, this));

            if (!back_.present()) {
                this->back_.set(::std::move(r));
                continue;
            }
        }

        // front
        //
        if (n.name() == "front" && n.namespace_().empty()) {
            ::std::unique_ptr<front_type> r(front_traits::create(i, f, this));

            if (!front_.present()) {
                this->front_.set(::std::move(r));
                continue;
            }
        }

        break;
    }

    if (!left_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("left", "");
    }

    if (!right_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("right", "");
    }

    if (!bottom_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("bottom", "");
    }

    if (!top_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("top", "");
    }

    if (!back_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("back", "");
    }

    if (!front_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("front", "");
    }
}

BoundaryConditionsType* BoundaryConditionsType::_clone(::xml_schema::flags f, ::xml_schema::container* c) const {
    return new class BoundaryConditionsType(*this, f, c);
}

BoundaryConditionsType& BoundaryConditionsType::operator=(const BoundaryConditionsType& x) {
    if (this != &x) {
        static_cast< ::xml_schema::type&>(*this) = x;
        this->left_ = x.left_;
        this->right_ = x.right_;
        this->bottom_ = x.bottom_;
        this->top_ = x.top_;
        this->back_ = x.back_;
        this->front_ = x.front_;
    }

    return *this;
}

BoundaryConditionsType::~BoundaryConditionsType() {}

// BoundaryType
//

BoundaryType::BoundaryType() : ::xml_schema::type(), outflow_(this), reflective_(this) {}

BoundaryType::BoundaryType(const BoundaryType& x, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c), outflow_(x.outflow_, f, this), reflective_(x.reflective_, f, this) {}

BoundaryType::BoundaryType(const ::xercesc::DOMElement& e, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), outflow_(this), reflective_(this) {
    if ((f & ::xml_schema::flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void BoundaryType::parse(::xsd::cxx::xml::dom::parser<char>& p, ::xml_schema::flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // outflow
        //
        if (n.name() == "outflow" && n.namespace_().empty()) {
            ::std::unique_ptr<outflow_type> r(outflow_traits::create(i, f, this));

            if (!this->outflow_) {
                this->outflow_.set(::std::move(r));
                continue;
            }
        }

        // reflective
        //
        if (n.name() == "reflective" && n.namespace_().empty()) {
            ::std::unique_ptr<reflective_type> r(reflective_traits::create(i, f, this));

            if (!this->reflective_) {
                this->reflective_.set(::std::move(r));
                continue;
            }
        }

        break;
    }
}

BoundaryType* BoundaryType::_clone(::xml_schema::flags f, ::xml_schema::container* c) const { return new class BoundaryType(*this, f, c); }

BoundaryType& BoundaryType::operator=(const BoundaryType& x) {
    if (this != &x) {
        static_cast< ::xml_schema::type&>(*this) = x;
        this->outflow_ = x.outflow_;
        this->reflective_ = x.reflective_;
    }

    return *this;
}

BoundaryType::~BoundaryType() {}

// OutflowBoundaryType
//

OutflowBoundaryType::OutflowBoundaryType() : ::xml_schema::type() {}

OutflowBoundaryType::OutflowBoundaryType(const OutflowBoundaryType& x, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c) {}

OutflowBoundaryType::OutflowBoundaryType(const ::xercesc::DOMElement& e, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f, c) {}

OutflowBoundaryType::OutflowBoundaryType(const ::xercesc::DOMAttr& a, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(a, f, c) {}

OutflowBoundaryType::OutflowBoundaryType(const ::std::string& s, const ::xercesc::DOMElement* e, ::xml_schema::flags f,
                                         ::xml_schema::container* c)
    : ::xml_schema::type(s, e, f, c) {}

OutflowBoundaryType* OutflowBoundaryType::_clone(::xml_schema::flags f, ::xml_schema::container* c) const {
    return new class OutflowBoundaryType(*this, f, c);
}

OutflowBoundaryType::~OutflowBoundaryType() {}

// ReflectiveBoundaryType
//

ReflectiveBoundaryType::ReflectiveBoundaryType() : ::xml_schema::type() {}

ReflectiveBoundaryType::ReflectiveBoundaryType(const ReflectiveBoundaryType& x, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c) {}

ReflectiveBoundaryType::ReflectiveBoundaryType(const ::xercesc::DOMElement& e, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f, c) {}

ReflectiveBoundaryType::ReflectiveBoundaryType(const ::xercesc::DOMAttr& a, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(a, f, c) {}

ReflectiveBoundaryType::ReflectiveBoundaryType(const ::std::string& s, const ::xercesc::DOMElement* e, ::xml_schema::flags f,
                                               ::xml_schema::container* c)
    : ::xml_schema::type(s, e, f, c) {}

ReflectiveBoundaryType* ReflectiveBoundaryType::_clone(::xml_schema::flags f, ::xml_schema::container* c) const {
    return new class ReflectiveBoundaryType(*this, f, c);
}

ReflectiveBoundaryType::~ReflectiveBoundaryType() {}

// CuboidSpawnerType
//

CuboidSpawnerType::CuboidSpawnerType(const lower_left_front_corner_type& lower_left_front_corner, const grid_dim_type& grid_dim,
                                     const grid_spacing_type& grid_spacing, const temperature_type& temperature, const mass_type& mass,
                                     const velocity_type& velocity, const type_type& type)
    : ::xml_schema::type(),
      lower_left_front_corner_(lower_left_front_corner, this),
      grid_dim_(grid_dim, this),
      grid_spacing_(grid_spacing, this),
      temperature_(temperature, this),
      mass_(mass, this),
      velocity_(velocity, this),
      type_(type, this) {}

CuboidSpawnerType::CuboidSpawnerType(::std::unique_ptr<lower_left_front_corner_type> lower_left_front_corner,
                                     ::std::unique_ptr<grid_dim_type> grid_dim, const grid_spacing_type& grid_spacing,
                                     const temperature_type& temperature, const mass_type& mass, ::std::unique_ptr<velocity_type> velocity,
                                     const type_type& type)
    : ::xml_schema::type(),
      lower_left_front_corner_(std::move(lower_left_front_corner), this),
      grid_dim_(std::move(grid_dim), this),
      grid_spacing_(grid_spacing, this),
      temperature_(temperature, this),
      mass_(mass, this),
      velocity_(std::move(velocity), this),
      type_(type, this) {}

CuboidSpawnerType::CuboidSpawnerType(const CuboidSpawnerType& x, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      lower_left_front_corner_(x.lower_left_front_corner_, f, this),
      grid_dim_(x.grid_dim_, f, this),
      grid_spacing_(x.grid_spacing_, f, this),
      temperature_(x.temperature_, f, this),
      mass_(x.mass_, f, this),
      velocity_(x.velocity_, f, this),
      type_(x.type_, f, this) {}

CuboidSpawnerType::CuboidSpawnerType(const ::xercesc::DOMElement& e, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      lower_left_front_corner_(this),
      grid_dim_(this),
      grid_spacing_(this),
      temperature_(this),
      mass_(this),
      velocity_(this),
      type_(this) {
    if ((f & ::xml_schema::flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void CuboidSpawnerType::parse(::xsd::cxx::xml::dom::parser<char>& p, ::xml_schema::flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // lower_left_front_corner
        //
        if (n.name() == "lower_left_front_corner" && n.namespace_().empty()) {
            ::std::unique_ptr<lower_left_front_corner_type> r(lower_left_front_corner_traits::create(i, f, this));

            if (!lower_left_front_corner_.present()) {
                this->lower_left_front_corner_.set(::std::move(r));
                continue;
            }
        }

        // grid_dim
        //
        if (n.name() == "grid_dim" && n.namespace_().empty()) {
            ::std::unique_ptr<grid_dim_type> r(grid_dim_traits::create(i, f, this));

            if (!grid_dim_.present()) {
                this->grid_dim_.set(::std::move(r));
                continue;
            }
        }

        // grid_spacing
        //
        if (n.name() == "grid_spacing" && n.namespace_().empty()) {
            if (!grid_spacing_.present()) {
                this->grid_spacing_.set(grid_spacing_traits::create(i, f, this));
                continue;
            }
        }

        // temperature
        //
        if (n.name() == "temperature" && n.namespace_().empty()) {
            if (!temperature_.present()) {
                this->temperature_.set(temperature_traits::create(i, f, this));
                continue;
            }
        }

        // mass
        //
        if (n.name() == "mass" && n.namespace_().empty()) {
            if (!mass_.present()) {
                this->mass_.set(mass_traits::create(i, f, this));
                continue;
            }
        }

        // velocity
        //
        if (n.name() == "velocity" && n.namespace_().empty()) {
            ::std::unique_ptr<velocity_type> r(velocity_traits::create(i, f, this));

            if (!velocity_.present()) {
                this->velocity_.set(::std::move(r));
                continue;
            }
        }

        // type
        //
        if (n.name() == "type" && n.namespace_().empty()) {
            if (!type_.present()) {
                this->type_.set(type_traits::create(i, f, this));
                continue;
            }
        }

        break;
    }

    if (!lower_left_front_corner_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("lower_left_front_corner", "");
    }

    if (!grid_dim_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("grid_dim", "");
    }

    if (!grid_spacing_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("grid_spacing", "");
    }

    if (!temperature_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("temperature", "");
    }

    if (!mass_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("mass", "");
    }

    if (!velocity_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("velocity", "");
    }

    if (!type_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("type", "");
    }
}

CuboidSpawnerType* CuboidSpawnerType::_clone(::xml_schema::flags f, ::xml_schema::container* c) const {
    return new class CuboidSpawnerType(*this, f, c);
}

CuboidSpawnerType& CuboidSpawnerType::operator=(const CuboidSpawnerType& x) {
    if (this != &x) {
        static_cast< ::xml_schema::type&>(*this) = x;
        this->lower_left_front_corner_ = x.lower_left_front_corner_;
        this->grid_dim_ = x.grid_dim_;
        this->grid_spacing_ = x.grid_spacing_;
        this->temperature_ = x.temperature_;
        this->mass_ = x.mass_;
        this->velocity_ = x.velocity_;
        this->type_ = x.type_;
    }

    return *this;
}

CuboidSpawnerType::~CuboidSpawnerType() {}

// SphereSpawnerType
//

SphereSpawnerType::SphereSpawnerType(const center_type& center, const radius_type& radius, const grid_spacing_type& grid_spacing,
                                     const temperature_type& temperature, const mass_type& mass, const velocity_type& velocity,
                                     const type_type& type)
    : ::xml_schema::type(),
      center_(center, this),
      radius_(radius, this),
      grid_spacing_(grid_spacing, this),
      temperature_(temperature, this),
      mass_(mass, this),
      velocity_(velocity, this),
      type_(type, this) {}

SphereSpawnerType::SphereSpawnerType(::std::unique_ptr<center_type> center, const radius_type& radius,
                                     const grid_spacing_type& grid_spacing, const temperature_type& temperature, const mass_type& mass,
                                     ::std::unique_ptr<velocity_type> velocity, const type_type& type)
    : ::xml_schema::type(),
      center_(std::move(center), this),
      radius_(radius, this),
      grid_spacing_(grid_spacing, this),
      temperature_(temperature, this),
      mass_(mass, this),
      velocity_(std::move(velocity), this),
      type_(type, this) {}

SphereSpawnerType::SphereSpawnerType(const SphereSpawnerType& x, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      center_(x.center_, f, this),
      radius_(x.radius_, f, this),
      grid_spacing_(x.grid_spacing_, f, this),
      temperature_(x.temperature_, f, this),
      mass_(x.mass_, f, this),
      velocity_(x.velocity_, f, this),
      type_(x.type_, f, this) {}

SphereSpawnerType::SphereSpawnerType(const ::xercesc::DOMElement& e, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      center_(this),
      radius_(this),
      grid_spacing_(this),
      temperature_(this),
      mass_(this),
      velocity_(this),
      type_(this) {
    if ((f & ::xml_schema::flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void SphereSpawnerType::parse(::xsd::cxx::xml::dom::parser<char>& p, ::xml_schema::flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // center
        //
        if (n.name() == "center" && n.namespace_().empty()) {
            ::std::unique_ptr<center_type> r(center_traits::create(i, f, this));

            if (!center_.present()) {
                this->center_.set(::std::move(r));
                continue;
            }
        }

        // radius
        //
        if (n.name() == "radius" && n.namespace_().empty()) {
            if (!radius_.present()) {
                this->radius_.set(radius_traits::create(i, f, this));
                continue;
            }
        }

        // grid_spacing
        //
        if (n.name() == "grid_spacing" && n.namespace_().empty()) {
            if (!grid_spacing_.present()) {
                this->grid_spacing_.set(grid_spacing_traits::create(i, f, this));
                continue;
            }
        }

        // temperature
        //
        if (n.name() == "temperature" && n.namespace_().empty()) {
            if (!temperature_.present()) {
                this->temperature_.set(temperature_traits::create(i, f, this));
                continue;
            }
        }

        // mass
        //
        if (n.name() == "mass" && n.namespace_().empty()) {
            if (!mass_.present()) {
                this->mass_.set(mass_traits::create(i, f, this));
                continue;
            }
        }

        // velocity
        //
        if (n.name() == "velocity" && n.namespace_().empty()) {
            ::std::unique_ptr<velocity_type> r(velocity_traits::create(i, f, this));

            if (!velocity_.present()) {
                this->velocity_.set(::std::move(r));
                continue;
            }
        }

        // type
        //
        if (n.name() == "type" && n.namespace_().empty()) {
            if (!type_.present()) {
                this->type_.set(type_traits::create(i, f, this));
                continue;
            }
        }

        break;
    }

    if (!center_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("center", "");
    }

    if (!radius_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("radius", "");
    }

    if (!grid_spacing_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("grid_spacing", "");
    }

    if (!temperature_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("temperature", "");
    }

    if (!mass_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("mass", "");
    }

    if (!velocity_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("velocity", "");
    }

    if (!type_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("type", "");
    }
}

SphereSpawnerType* SphereSpawnerType::_clone(::xml_schema::flags f, ::xml_schema::container* c) const {
    return new class SphereSpawnerType(*this, f, c);
}

SphereSpawnerType& SphereSpawnerType::operator=(const SphereSpawnerType& x) {
    if (this != &x) {
        static_cast< ::xml_schema::type&>(*this) = x;
        this->center_ = x.center_;
        this->radius_ = x.radius_;
        this->grid_spacing_ = x.grid_spacing_;
        this->temperature_ = x.temperature_;
        this->mass_ = x.mass_;
        this->velocity_ = x.velocity_;
        this->type_ = x.type_;
    }

    return *this;
}

SphereSpawnerType::~SphereSpawnerType() {}

// ParticleType
//

ParticleType::ParticleType(const position_type& position, const temperature_type& temperature, const mass_type& mass,
                           const velocity_type& velocity, const type_type& type)
    : ::xml_schema::type(),
      position_(position, this),
      temperature_(temperature, this),
      mass_(mass, this),
      velocity_(velocity, this),
      type_(type, this) {}

ParticleType::ParticleType(::std::unique_ptr<position_type> position, const temperature_type& temperature, const mass_type& mass,
                           ::std::unique_ptr<velocity_type> velocity, const type_type& type)
    : ::xml_schema::type(),
      position_(std::move(position), this),
      temperature_(temperature, this),
      mass_(mass, this),
      velocity_(std::move(velocity), this),
      type_(type, this) {}

ParticleType::ParticleType(const ParticleType& x, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      position_(x.position_, f, this),
      temperature_(x.temperature_, f, this),
      mass_(x.mass_, f, this),
      velocity_(x.velocity_, f, this),
      type_(x.type_, f, this) {}

ParticleType::ParticleType(const ::xercesc::DOMElement& e, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      position_(this),
      temperature_(this),
      mass_(this),
      velocity_(this),
      type_(this) {
    if ((f & ::xml_schema::flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void ParticleType::parse(::xsd::cxx::xml::dom::parser<char>& p, ::xml_schema::flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // position
        //
        if (n.name() == "position" && n.namespace_().empty()) {
            ::std::unique_ptr<position_type> r(position_traits::create(i, f, this));

            if (!position_.present()) {
                this->position_.set(::std::move(r));
                continue;
            }
        }

        // temperature
        //
        if (n.name() == "temperature" && n.namespace_().empty()) {
            if (!temperature_.present()) {
                this->temperature_.set(temperature_traits::create(i, f, this));
                continue;
            }
        }

        // mass
        //
        if (n.name() == "mass" && n.namespace_().empty()) {
            if (!mass_.present()) {
                this->mass_.set(mass_traits::create(i, f, this));
                continue;
            }
        }

        // velocity
        //
        if (n.name() == "velocity" && n.namespace_().empty()) {
            ::std::unique_ptr<velocity_type> r(velocity_traits::create(i, f, this));

            if (!velocity_.present()) {
                this->velocity_.set(::std::move(r));
                continue;
            }
        }

        // type
        //
        if (n.name() == "type" && n.namespace_().empty()) {
            if (!type_.present()) {
                this->type_.set(type_traits::create(i, f, this));
                continue;
            }
        }

        break;
    }

    if (!position_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("position", "");
    }

    if (!temperature_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("temperature", "");
    }

    if (!mass_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("mass", "");
    }

    if (!velocity_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("velocity", "");
    }

    if (!type_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("type", "");
    }
}

ParticleType* ParticleType::_clone(::xml_schema::flags f, ::xml_schema::container* c) const { return new class ParticleType(*this, f, c); }

ParticleType& ParticleType::operator=(const ParticleType& x) {
    if (this != &x) {
        static_cast< ::xml_schema::type&>(*this) = x;
        this->position_ = x.position_;
        this->temperature_ = x.temperature_;
        this->mass_ = x.mass_;
        this->velocity_ = x.velocity_;
        this->type_ = x.type_;
    }

    return *this;
}

ParticleType::~ParticleType() {}

// configuration
//

configuration::configuration(const settings_type& settings, const particles_type& particles)
    : ::xml_schema::type(), settings_(settings, this), particles_(particles, this) {}

configuration::configuration(::std::unique_ptr<settings_type> settings, ::std::unique_ptr<particles_type> particles)
    : ::xml_schema::type(), settings_(std::move(settings), this), particles_(std::move(particles), this) {}

configuration::configuration(const configuration& x, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c), settings_(x.settings_, f, this), particles_(x.particles_, f, this) {}

configuration::configuration(const ::xercesc::DOMElement& e, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), settings_(this), particles_(this) {
    if ((f & ::xml_schema::flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void configuration::parse(::xsd::cxx::xml::dom::parser<char>& p, ::xml_schema::flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // settings
        //
        if (n.name() == "settings" && n.namespace_().empty()) {
            ::std::unique_ptr<settings_type> r(settings_traits::create(i, f, this));

            if (!settings_.present()) {
                this->settings_.set(::std::move(r));
                continue;
            }
        }

        // particles
        //
        if (n.name() == "particles" && n.namespace_().empty()) {
            ::std::unique_ptr<particles_type> r(particles_traits::create(i, f, this));

            if (!particles_.present()) {
                this->particles_.set(::std::move(r));
                continue;
            }
        }

        break;
    }

    if (!settings_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("settings", "");
    }

    if (!particles_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("particles", "");
    }
}

configuration* configuration::_clone(::xml_schema::flags f, ::xml_schema::container* c) const {
    return new class configuration(*this, f, c);
}

configuration& configuration::operator=(const configuration& x) {
    if (this != &x) {
        static_cast< ::xml_schema::type&>(*this) = x;
        this->settings_ = x.settings_;
        this->particles_ = x.particles_;
    }

    return *this;
}

configuration::~configuration() {}

// settings
//

settings::settings(const fps_type& fps, const video_length_type& video_length, const delta_t_type& delta_t, const end_time_type& end_time,
                   const third_dimension_type& third_dimension, const particle_container_type& particle_container)
    : ::xml_schema::type(),
      fps_(fps, this),
      video_length_(video_length, this),
      delta_t_(delta_t, this),
      end_time_(end_time, this),
      third_dimension_(third_dimension, this),
      particle_container_(particle_container, this) {}

settings::settings(const fps_type& fps, const video_length_type& video_length, const delta_t_type& delta_t, const end_time_type& end_time,
                   const third_dimension_type& third_dimension, ::std::unique_ptr<particle_container_type> particle_container)
    : ::xml_schema::type(),
      fps_(fps, this),
      video_length_(video_length, this),
      delta_t_(delta_t, this),
      end_time_(end_time, this),
      third_dimension_(third_dimension, this),
      particle_container_(std::move(particle_container), this) {}

settings::settings(const settings& x, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      fps_(x.fps_, f, this),
      video_length_(x.video_length_, f, this),
      delta_t_(x.delta_t_, f, this),
      end_time_(x.end_time_, f, this),
      third_dimension_(x.third_dimension_, f, this),
      particle_container_(x.particle_container_, f, this) {}

settings::settings(const ::xercesc::DOMElement& e, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c),
      fps_(this),
      video_length_(this),
      delta_t_(this),
      end_time_(this),
      third_dimension_(this),
      particle_container_(this) {
    if ((f & ::xml_schema::flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void settings::parse(::xsd::cxx::xml::dom::parser<char>& p, ::xml_schema::flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // fps
        //
        if (n.name() == "fps" && n.namespace_().empty()) {
            if (!fps_.present()) {
                this->fps_.set(fps_traits::create(i, f, this));
                continue;
            }
        }

        // video_length
        //
        if (n.name() == "video_length" && n.namespace_().empty()) {
            if (!video_length_.present()) {
                this->video_length_.set(video_length_traits::create(i, f, this));
                continue;
            }
        }

        // delta_t
        //
        if (n.name() == "delta_t" && n.namespace_().empty()) {
            if (!delta_t_.present()) {
                this->delta_t_.set(delta_t_traits::create(i, f, this));
                continue;
            }
        }

        // end_time
        //
        if (n.name() == "end_time" && n.namespace_().empty()) {
            if (!end_time_.present()) {
                this->end_time_.set(end_time_traits::create(i, f, this));
                continue;
            }
        }

        // third_dimension
        //
        if (n.name() == "third_dimension" && n.namespace_().empty()) {
            if (!third_dimension_.present()) {
                this->third_dimension_.set(third_dimension_traits::create(i, f, this));
                continue;
            }
        }

        // particle_container
        //
        if (n.name() == "particle_container" && n.namespace_().empty()) {
            ::std::unique_ptr<particle_container_type> r(particle_container_traits::create(i, f, this));

            if (!particle_container_.present()) {
                this->particle_container_.set(::std::move(r));
                continue;
            }
        }

        break;
    }

    if (!fps_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("fps", "");
    }

    if (!video_length_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("video_length", "");
    }

    if (!delta_t_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("delta_t", "");
    }

    if (!end_time_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("end_time", "");
    }

    if (!third_dimension_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("third_dimension", "");
    }

    if (!particle_container_.present()) {
        throw ::xsd::cxx::tree::expected_element<char>("particle_container", "");
    }
}

settings* settings::_clone(::xml_schema::flags f, ::xml_schema::container* c) const { return new class settings(*this, f, c); }

settings& settings::operator=(const settings& x) {
    if (this != &x) {
        static_cast< ::xml_schema::type&>(*this) = x;
        this->fps_ = x.fps_;
        this->video_length_ = x.video_length_;
        this->delta_t_ = x.delta_t_;
        this->end_time_ = x.end_time_;
        this->third_dimension_ = x.third_dimension_;
        this->particle_container_ = x.particle_container_;
    }

    return *this;
}

settings::~settings() {}

// particles
//

particles::particles() : ::xml_schema::type(), cuboid_spawner_(this), sphere_spawner_(this), single_particle_(this) {}

particles::particles(const particles& x, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(x, f, c),
      cuboid_spawner_(x.cuboid_spawner_, f, this),
      sphere_spawner_(x.sphere_spawner_, f, this),
      single_particle_(x.single_particle_, f, this) {}

particles::particles(const ::xercesc::DOMElement& e, ::xml_schema::flags f, ::xml_schema::container* c)
    : ::xml_schema::type(e, f | ::xml_schema::flags::base, c), cuboid_spawner_(this), sphere_spawner_(this), single_particle_(this) {
    if ((f & ::xml_schema::flags::base) == 0) {
        ::xsd::cxx::xml::dom::parser<char> p(e, true, false, false);
        this->parse(p, f);
    }
}

void particles::parse(::xsd::cxx::xml::dom::parser<char>& p, ::xml_schema::flags f) {
    for (; p.more_content(); p.next_content(false)) {
        const ::xercesc::DOMElement& i(p.cur_element());
        const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(i));

        // cuboid_spawner
        //
        if (n.name() == "cuboid_spawner" && n.namespace_().empty()) {
            ::std::unique_ptr<cuboid_spawner_type> r(cuboid_spawner_traits::create(i, f, this));

            this->cuboid_spawner_.push_back(::std::move(r));
            continue;
        }

        // sphere_spawner
        //
        if (n.name() == "sphere_spawner" && n.namespace_().empty()) {
            ::std::unique_ptr<sphere_spawner_type> r(sphere_spawner_traits::create(i, f, this));

            this->sphere_spawner_.push_back(::std::move(r));
            continue;
        }

        // single_particle
        //
        if (n.name() == "single_particle" && n.namespace_().empty()) {
            ::std::unique_ptr<single_particle_type> r(single_particle_traits::create(i, f, this));

            this->single_particle_.push_back(::std::move(r));
            continue;
        }

        break;
    }
}

particles* particles::_clone(::xml_schema::flags f, ::xml_schema::container* c) const { return new class particles(*this, f, c); }

particles& particles::operator=(const particles& x) {
    if (this != &x) {
        static_cast< ::xml_schema::type&>(*this) = x;
        this->cuboid_spawner_ = x.cuboid_spawner_;
        this->sphere_spawner_ = x.sphere_spawner_;
        this->single_particle_ = x.single_particle_;
    }

    return *this;
}

particles::~particles() {}

#include <istream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/sax/std-input-source.hxx>

::std::unique_ptr< ::configuration> configuration_(const ::std::string& u, ::xml_schema::flags f, const ::xml_schema::properties& p) {
    ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::flags::dont_initialize) == 0, (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler<char> h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing<char> >();

    return ::std::unique_ptr< ::configuration>(::configuration_(std::move(d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::configuration> configuration_(const ::std::string& u, ::xml_schema::error_handler& h, ::xml_schema::flags f,
                                                   const ::xml_schema::properties& p) {
    ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::flags::dont_initialize) == 0, (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

    if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

    return ::std::unique_ptr< ::configuration>(::configuration_(std::move(d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::configuration> configuration_(const ::std::string& u, ::xercesc::DOMErrorHandler& h, ::xml_schema::flags f,
                                                   const ::xml_schema::properties& p) {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(u, h, p, f));

    if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

    return ::std::unique_ptr< ::configuration>(::configuration_(std::move(d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::configuration> configuration_(::std::istream& is, ::xml_schema::flags f, const ::xml_schema::properties& p) {
    ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::flags::dont_initialize) == 0, (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc(is);
    return ::configuration_(isrc, f, p);
}

::std::unique_ptr< ::configuration> configuration_(::std::istream& is, ::xml_schema::error_handler& h, ::xml_schema::flags f,
                                                   const ::xml_schema::properties& p) {
    ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::flags::dont_initialize) == 0, (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc(is);
    return ::configuration_(isrc, h, f, p);
}

::std::unique_ptr< ::configuration> configuration_(::std::istream& is, ::xercesc::DOMErrorHandler& h, ::xml_schema::flags f,
                                                   const ::xml_schema::properties& p) {
    ::xsd::cxx::xml::sax::std_input_source isrc(is);
    return ::configuration_(isrc, h, f, p);
}

::std::unique_ptr< ::configuration> configuration_(::std::istream& is, const ::std::string& sid, ::xml_schema::flags f,
                                                   const ::xml_schema::properties& p) {
    ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::flags::dont_initialize) == 0, (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
    return ::configuration_(isrc, f, p);
}

::std::unique_ptr< ::configuration> configuration_(::std::istream& is, const ::std::string& sid, ::xml_schema::error_handler& h,
                                                   ::xml_schema::flags f, const ::xml_schema::properties& p) {
    ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::flags::dont_initialize) == 0, (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
    return ::configuration_(isrc, h, f, p);
}

::std::unique_ptr< ::configuration> configuration_(::std::istream& is, const ::std::string& sid, ::xercesc::DOMErrorHandler& h,
                                                   ::xml_schema::flags f, const ::xml_schema::properties& p) {
    ::xsd::cxx::xml::sax::std_input_source isrc(is, sid);
    return ::configuration_(isrc, h, f, p);
}

::std::unique_ptr< ::configuration> configuration_(::xercesc::InputSource& i, ::xml_schema::flags f, const ::xml_schema::properties& p) {
    ::xsd::cxx::tree::error_handler<char> h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing<char> >();

    return ::std::unique_ptr< ::configuration>(::configuration_(std::move(d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::configuration> configuration_(::xercesc::InputSource& i, ::xml_schema::error_handler& h, ::xml_schema::flags f,
                                                   const ::xml_schema::properties& p) {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

    if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

    return ::std::unique_ptr< ::configuration>(::configuration_(std::move(d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::configuration> configuration_(::xercesc::InputSource& i, ::xercesc::DOMErrorHandler& h, ::xml_schema::flags f,
                                                   const ::xml_schema::properties& p) {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::parse<char>(i, h, p, f));

    if (!d.get()) throw ::xsd::cxx::tree::parsing<char>();

    return ::std::unique_ptr< ::configuration>(::configuration_(std::move(d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::configuration> configuration_(const ::xercesc::DOMDocument& doc, ::xml_schema::flags f,
                                                   const ::xml_schema::properties& p) {
    if (f & ::xml_schema::flags::keep_dom) {
        ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(static_cast< ::xercesc::DOMDocument*>(doc.cloneNode(true)));

        return ::std::unique_ptr< ::configuration>(::configuration_(std::move(d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e(*doc.getDocumentElement());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(e));

    if (n.name() == "configuration" && n.namespace_() == "") {
        ::std::unique_ptr< ::configuration> r(::xsd::cxx::tree::traits< ::configuration, char>::create(e, f, 0));
        return r;
    }

    throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(), "configuration", "");
}

::std::unique_ptr< ::configuration> configuration_(::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d, ::xml_schema::flags f,
                                                   const ::xml_schema::properties&) {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> c(((f & ::xml_schema::flags::keep_dom) && !(f & ::xml_schema::flags::own_dom))
                                                                 ? static_cast< ::xercesc::DOMDocument*>(d->cloneNode(true))
                                                                 : 0);

    ::xercesc::DOMDocument& doc(c.get() ? *c : *d);
    const ::xercesc::DOMElement& e(*doc.getDocumentElement());

    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(e));

    if (f & ::xml_schema::flags::keep_dom) doc.setUserData(::xml_schema::dom::tree_node_key, (c.get() ? &c : &d), 0);

    if (n.name() == "configuration" && n.namespace_() == "") {
        ::std::unique_ptr< ::configuration> r(::xsd::cxx::tree::traits< ::configuration, char>::create(e, f, 0));
        return r;
    }

    throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(), "configuration", "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void configuration_(::std::ostream& o, const ::configuration& s, const ::xml_schema::namespace_infomap& m, const ::std::string& e,
                    ::xml_schema::flags f) {
    ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::configuration_(s, m, f));

    ::xsd::cxx::tree::error_handler<char> h;

    ::xsd::cxx::xml::dom::ostream_format_target t(o);
    if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
        h.throw_if_failed< ::xsd::cxx::tree::serialization<char> >();
    }
}

void configuration_(::std::ostream& o, const ::configuration& s, ::xml_schema::error_handler& h, const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e, ::xml_schema::flags f) {
    ::xsd::cxx::xml::auto_initializer i((f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::configuration_(s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t(o);
    if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
        throw ::xsd::cxx::tree::serialization<char>();
    }
}

void configuration_(::std::ostream& o, const ::configuration& s, ::xercesc::DOMErrorHandler& h, const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e, ::xml_schema::flags f) {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::configuration_(s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t(o);
    if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
        throw ::xsd::cxx::tree::serialization<char>();
    }
}

void configuration_(::xercesc::XMLFormatTarget& t, const ::configuration& s, const ::xml_schema::namespace_infomap& m,
                    const ::std::string& e, ::xml_schema::flags f) {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::configuration_(s, m, f));

    ::xsd::cxx::tree::error_handler<char> h;

    if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
        h.throw_if_failed< ::xsd::cxx::tree::serialization<char> >();
    }
}

void configuration_(::xercesc::XMLFormatTarget& t, const ::configuration& s, ::xml_schema::error_handler& h,
                    const ::xml_schema::namespace_infomap& m, const ::std::string& e, ::xml_schema::flags f) {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::configuration_(s, m, f));
    if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
        throw ::xsd::cxx::tree::serialization<char>();
    }
}

void configuration_(::xercesc::XMLFormatTarget& t, const ::configuration& s, ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::namespace_infomap& m, const ::std::string& e, ::xml_schema::flags f) {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::configuration_(s, m, f));
    if (!::xsd::cxx::xml::dom::serialize(t, *d, e, h, f)) {
        throw ::xsd::cxx::tree::serialization<char>();
    }
}

void configuration_(::xercesc::DOMDocument& d, const ::configuration& s, ::xml_schema::flags) {
    ::xercesc::DOMElement& e(*d.getDocumentElement());
    const ::xsd::cxx::xml::qualified_name<char> n(::xsd::cxx::xml::dom::name<char>(e));

    if (n.name() == "configuration" && n.namespace_() == "") {
        e << s;
    } else {
        throw ::xsd::cxx::tree::unexpected_element<char>(n.name(), n.namespace_(), "configuration", "");
    }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> configuration_(const ::configuration& s, const ::xml_schema::namespace_infomap& m,
                                                                      ::xml_schema::flags f) {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument> d(::xsd::cxx::xml::dom::serialize<char>("configuration", "", m, f));

    ::configuration_(*d, s, f);
    return d;
}

void operator<<(::xercesc::DOMElement& e, const DoubleVec3Type& i) {
    e << static_cast<const ::xml_schema::type&>(i);

    // x
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("x", e));

        s << ::xml_schema::as_double(i.x());
    }

    // y
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("y", e));

        s << ::xml_schema::as_double(i.y());
    }

    // z
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("z", e));

        s << ::xml_schema::as_double(i.z());
    }
}

void operator<<(::xercesc::DOMElement& e, const IntVec3Type& i) {
    e << static_cast<const ::xml_schema::type&>(i);

    // x
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("x", e));

        s << i.x();
    }

    // y
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("y", e));

        s << i.y();
    }

    // z
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("z", e));

        s << i.z();
    }
}

void operator<<(::xercesc::DOMElement& e, const ParticleContainerType& i) {
    e << static_cast<const ::xml_schema::type&>(i);

    // directsum_container
    //
    if (i.directsum_container()) {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("directsum_container", e));

        s << *i.directsum_container();
    }

    // linkedcells_container
    //
    if (i.linkedcells_container()) {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("linkedcells_container", e));

        s << *i.linkedcells_container();
    }
}

void operator<<(::xercesc::DOMElement& e, const DirectSumContainerType& i) { e << static_cast<const ::xml_schema::type&>(i); }

void operator<<(::xercesc::DOMAttr&, const DirectSumContainerType&) {}

void operator<<(::xml_schema::list_stream&, const DirectSumContainerType&) {}

void operator<<(::xercesc::DOMElement& e, const LinkedCellsContainerType& i) {
    e << static_cast<const ::xml_schema::type&>(i);

    // domain_size
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("domain_size", e));

        s << i.domain_size();
    }

    // cutoff_radius
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("cutoff_radius", e));

        s << ::xml_schema::as_double(i.cutoff_radius());
    }

    // boundary_conditions
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("boundary_conditions", e));

        s << i.boundary_conditions();
    }
}

void operator<<(::xercesc::DOMElement& e, const BoundaryConditionsType& i) {
    e << static_cast<const ::xml_schema::type&>(i);

    // left
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("left", e));

        s << i.left();
    }

    // right
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("right", e));

        s << i.right();
    }

    // bottom
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("bottom", e));

        s << i.bottom();
    }

    // top
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("top", e));

        s << i.top();
    }

    // back
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("back", e));

        s << i.back();
    }

    // front
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("front", e));

        s << i.front();
    }
}

void operator<<(::xercesc::DOMElement& e, const BoundaryType& i) {
    e << static_cast<const ::xml_schema::type&>(i);

    // outflow
    //
    if (i.outflow()) {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("outflow", e));

        s << *i.outflow();
    }

    // reflective
    //
    if (i.reflective()) {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("reflective", e));

        s << *i.reflective();
    }
}

void operator<<(::xercesc::DOMElement& e, const OutflowBoundaryType& i) { e << static_cast<const ::xml_schema::type&>(i); }

void operator<<(::xercesc::DOMAttr&, const OutflowBoundaryType&) {}

void operator<<(::xml_schema::list_stream&, const OutflowBoundaryType&) {}

void operator<<(::xercesc::DOMElement& e, const ReflectiveBoundaryType& i) { e << static_cast<const ::xml_schema::type&>(i); }

void operator<<(::xercesc::DOMAttr&, const ReflectiveBoundaryType&) {}

void operator<<(::xml_schema::list_stream&, const ReflectiveBoundaryType&) {}

void operator<<(::xercesc::DOMElement& e, const CuboidSpawnerType& i) {
    e << static_cast<const ::xml_schema::type&>(i);

    // lower_left_front_corner
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("lower_left_front_corner", e));

        s << i.lower_left_front_corner();
    }

    // grid_dim
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("grid_dim", e));

        s << i.grid_dim();
    }

    // grid_spacing
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("grid_spacing", e));

        s << ::xml_schema::as_double(i.grid_spacing());
    }

    // temperature
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("temperature", e));

        s << ::xml_schema::as_double(i.temperature());
    }

    // mass
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("mass", e));

        s << ::xml_schema::as_double(i.mass());
    }

    // velocity
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("velocity", e));

        s << i.velocity();
    }

    // type
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("type", e));

        s << i.type();
    }
}

void operator<<(::xercesc::DOMElement& e, const SphereSpawnerType& i) {
    e << static_cast<const ::xml_schema::type&>(i);

    // center
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("center", e));

        s << i.center();
    }

    // radius
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("radius", e));

        s << i.radius();
    }

    // grid_spacing
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("grid_spacing", e));

        s << ::xml_schema::as_double(i.grid_spacing());
    }

    // temperature
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("temperature", e));

        s << ::xml_schema::as_double(i.temperature());
    }

    // mass
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("mass", e));

        s << ::xml_schema::as_double(i.mass());
    }

    // velocity
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("velocity", e));

        s << i.velocity();
    }

    // type
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("type", e));

        s << i.type();
    }
}

void operator<<(::xercesc::DOMElement& e, const ParticleType& i) {
    e << static_cast<const ::xml_schema::type&>(i);

    // position
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("position", e));

        s << i.position();
    }

    // temperature
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("temperature", e));

        s << ::xml_schema::as_double(i.temperature());
    }

    // mass
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("mass", e));

        s << ::xml_schema::as_double(i.mass());
    }

    // velocity
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("velocity", e));

        s << i.velocity();
    }

    // type
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("type", e));

        s << i.type();
    }
}

void operator<<(::xercesc::DOMElement& e, const configuration& i) {
    e << static_cast<const ::xml_schema::type&>(i);

    // settings
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("settings", e));

        s << i.settings();
    }

    // particles
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("particles", e));

        s << i.particles();
    }
}

void operator<<(::xercesc::DOMElement& e, const settings& i) {
    e << static_cast<const ::xml_schema::type&>(i);

    // fps
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("fps", e));

        s << i.fps();
    }

    // video_length
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("video_length", e));

        s << i.video_length();
    }

    // delta_t
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("delta_t", e));

        s << ::xml_schema::as_double(i.delta_t());
    }

    // end_time
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("end_time", e));

        s << ::xml_schema::as_double(i.end_time());
    }

    // third_dimension
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("third_dimension", e));

        s << i.third_dimension();
    }

    // particle_container
    //
    {
        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("particle_container", e));

        s << i.particle_container();
    }
}

void operator<<(::xercesc::DOMElement& e, const particles& i) {
    e << static_cast<const ::xml_schema::type&>(i);

    // cuboid_spawner
    //
    for (particles::cuboid_spawner_const_iterator b(i.cuboid_spawner().begin()), n(i.cuboid_spawner().end()); b != n; ++b) {
        const particles::cuboid_spawner_type& x(*b);

        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("cuboid_spawner", e));

        s << x;
    }

    // sphere_spawner
    //
    for (particles::sphere_spawner_const_iterator b(i.sphere_spawner().begin()), n(i.sphere_spawner().end()); b != n; ++b) {
        const particles::sphere_spawner_type& x(*b);

        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("sphere_spawner", e));

        s << x;
    }

    // single_particle
    //
    for (particles::single_particle_const_iterator b(i.single_particle().begin()), n(i.single_particle().end()); b != n; ++b) {
        const particles::single_particle_type& x(*b);

        ::xercesc::DOMElement& s(::xsd::cxx::xml::dom::create_element("single_particle", e));

        s << x;
    }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.
