// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "simulation_schema-pskel.hxx"

#include <xsd/cxx/pre.hxx>

// positionType_pskel
//

void positionType_pskel::x_parser(::xml_schema::decimal_pskel& p) { this->x_parser_ = &p; }

void positionType_pskel::y_parser(::xml_schema::decimal_pskel& p) { this->y_parser_ = &p; }

void positionType_pskel::z_parser(::xml_schema::decimal_pskel& p) { this->z_parser_ = &p; }

void positionType_pskel::parsers(::xml_schema::decimal_pskel& x, ::xml_schema::decimal_pskel& y, ::xml_schema::decimal_pskel& z) {
    this->x_parser_ = &x;
    this->y_parser_ = &y;
    this->z_parser_ = &z;
}

positionType_pskel::positionType_pskel() : x_parser_(0), y_parser_(0), z_parser_(0), v_state_stack_(sizeof(v_state_), &v_state_first_) {}

// gridDimType_pskel
//

void gridDimType_pskel::dimx_parser(::xml_schema::integer_pskel& p) { this->dimx_parser_ = &p; }

void gridDimType_pskel::dimy_parser(::xml_schema::integer_pskel& p) { this->dimy_parser_ = &p; }

void gridDimType_pskel::dimz_parser(::xml_schema::integer_pskel& p) { this->dimz_parser_ = &p; }

void gridDimType_pskel::parsers(::xml_schema::integer_pskel& dimx, ::xml_schema::integer_pskel& dimy, ::xml_schema::integer_pskel& dimz) {
    this->dimx_parser_ = &dimx;
    this->dimy_parser_ = &dimy;
    this->dimz_parser_ = &dimz;
}

gridDimType_pskel::gridDimType_pskel()
    : dimx_parser_(0), dimy_parser_(0), dimz_parser_(0), v_state_stack_(sizeof(v_state_), &v_state_first_) {}

// velocityType_pskel
//

void velocityType_pskel::x_parser(::xml_schema::decimal_pskel& p) { this->x_parser_ = &p; }

void velocityType_pskel::y_parser(::xml_schema::decimal_pskel& p) { this->y_parser_ = &p; }

void velocityType_pskel::z_parser(::xml_schema::decimal_pskel& p) { this->z_parser_ = &p; }

void velocityType_pskel::parsers(::xml_schema::decimal_pskel& x, ::xml_schema::decimal_pskel& y, ::xml_schema::decimal_pskel& z) {
    this->x_parser_ = &x;
    this->y_parser_ = &y;
    this->z_parser_ = &z;
}

velocityType_pskel::velocityType_pskel() : x_parser_(0), y_parser_(0), z_parser_(0), v_state_stack_(sizeof(v_state_), &v_state_first_) {}

// configuration_pskel
//

void configuration_pskel::fps_parser(::xml_schema::integer_pskel& p) { this->fps_parser_ = &p; }

void configuration_pskel::video_length_parser(::xml_schema::integer_pskel& p) { this->video_length_parser_ = &p; }

void configuration_pskel::delta_t_parser(::xml_schema::decimal_pskel& p) { this->delta_t_parser_ = &p; }

void configuration_pskel::end_time_parser(::xml_schema::decimal_pskel& p) { this->end_time_parser_ = &p; }

void configuration_pskel::cuboid_parser(::cuboid_pskel& p) { this->cuboid_parser_ = &p; }

void configuration_pskel::parsers(::xml_schema::integer_pskel& fps, ::xml_schema::integer_pskel& video_length,
                                  ::xml_schema::decimal_pskel& delta_t, ::xml_schema::decimal_pskel& end_time, ::cuboid_pskel& cuboid) {
    this->fps_parser_ = &fps;
    this->video_length_parser_ = &video_length;
    this->delta_t_parser_ = &delta_t;
    this->end_time_parser_ = &end_time;
    this->cuboid_parser_ = &cuboid;
}

configuration_pskel::configuration_pskel()
    : fps_parser_(0),
      video_length_parser_(0),
      delta_t_parser_(0),
      end_time_parser_(0),
      cuboid_parser_(0),
      v_state_stack_(sizeof(v_state_), &v_state_first_) {}

// cuboid_pskel
//

void cuboid_pskel::position_parser(::positionType_pskel& p) { this->position_parser_ = &p; }

void cuboid_pskel::grid_dim_parser(::gridDimType_pskel& p) { this->grid_dim_parser_ = &p; }

void cuboid_pskel::grid_spacing_parser(::xml_schema::decimal_pskel& p) { this->grid_spacing_parser_ = &p; }

void cuboid_pskel::temperature_parser(::xml_schema::decimal_pskel& p) { this->temperature_parser_ = &p; }

void cuboid_pskel::mass_parser(::xml_schema::decimal_pskel& p) { this->mass_parser_ = &p; }

void cuboid_pskel::velocity_parser(::velocityType_pskel& p) { this->velocity_parser_ = &p; }

void cuboid_pskel::type_parser(::xml_schema::integer_pskel& p) { this->type_parser_ = &p; }

void cuboid_pskel::parsers(::positionType_pskel& position, ::gridDimType_pskel& grid_dim, ::xml_schema::decimal_pskel& grid_spacing,
                           ::xml_schema::decimal_pskel& temperature, ::xml_schema::decimal_pskel& mass, ::velocityType_pskel& velocity,
                           ::xml_schema::integer_pskel& type) {
    this->position_parser_ = &position;
    this->grid_dim_parser_ = &grid_dim;
    this->grid_spacing_parser_ = &grid_spacing;
    this->temperature_parser_ = &temperature;
    this->mass_parser_ = &mass;
    this->velocity_parser_ = &velocity;
    this->type_parser_ = &type;
}

cuboid_pskel::cuboid_pskel()
    : position_parser_(0),
      grid_dim_parser_(0),
      grid_spacing_parser_(0),
      temperature_parser_(0),
      mass_parser_(0),
      velocity_parser_(0),
      type_parser_(0),
      v_state_stack_(sizeof(v_state_), &v_state_first_) {}

// positionType_pskel
//

void positionType_pskel::x(double) {}

void positionType_pskel::y(double) {}

void positionType_pskel::z(double) {}

void positionType_pskel::post_positionType() {}

// gridDimType_pskel
//

void gridDimType_pskel::dimx(long long) {}

void gridDimType_pskel::dimy(long long) {}

void gridDimType_pskel::dimz(long long) {}

void gridDimType_pskel::post_gridDimType() {}

// velocityType_pskel
//

void velocityType_pskel::x(double) {}

void velocityType_pskel::y(double) {}

void velocityType_pskel::z(double) {}

void velocityType_pskel::post_velocityType() {}

// configuration_pskel
//

void configuration_pskel::fps(long long) {}

void configuration_pskel::video_length(long long) {}

void configuration_pskel::delta_t(double) {}

void configuration_pskel::end_time(double) {}

void configuration_pskel::cuboid() {}

void configuration_pskel::post_configuration() {}

// cuboid_pskel
//

void cuboid_pskel::position() {}

void cuboid_pskel::grid_dim() {}

void cuboid_pskel::grid_spacing(double) {}

void cuboid_pskel::temperature(double) {}

void cuboid_pskel::mass(double) {}

void cuboid_pskel::velocity() {}

void cuboid_pskel::type(long long) {}

void cuboid_pskel::post_cuboid() {}

#include <cassert>

// Element validation and dispatch functions for positionType_pskel.
//
bool positionType_pskel::_start_element_impl(const ::xml_schema::ro_string& ns, const ::xml_schema::ro_string& n,
                                             const ::xml_schema::ro_string* t) {
    XSD_UNUSED(t);

    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0) {
        if (this->::xml_schema::complex_content::_start_element_impl(ns, n, t))
            return true;
        else
            vd->state = 1;
    }

    while (vd->func != 0) {
        (this->*vd->func)(vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
        else
            break;
    }

    if (vd->func == 0) {
        if (vd->state != ~0UL) {
            unsigned long s = ~0UL;

            if (n == "x" && ns.empty()) s = 0UL;

            if (s != ~0UL) {
                vd->count++;
                vd->state = ~0UL;

                vd = vs.data + vs.size++;
                vd->func = &positionType_pskel::sequence_0;
                vd->state = s;
                vd->count = 0;

                this->sequence_0(vd->state, vd->count, ns, n, t, true);
            } else {
                if (vd->count < 1UL) this->_expected_element("", "x", ns, n);
                return false;
            }
        } else
            return false;
    }

    return true;
}

bool positionType_pskel::_end_element_impl(const ::xml_schema::ro_string& ns, const ::xml_schema::ro_string& n) {
    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0) {
        if (!::xml_schema::complex_content::_end_element_impl(ns, n)) assert(false);
        return true;
    }

    assert(vd.func != 0);
    (this->*vd.func)(vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL) vs.size--;

    return true;
}

void positionType_pskel::_pre_e_validate() {
    this->v_state_stack_.push();
    static_cast<v_state_*>(this->v_state_stack_.top())->size = 0;

    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
}

void positionType_pskel::_post_e_validate() {
    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0) {
        (this->*vd->func)(vd->state, vd->count, empty, empty, 0, true);
        assert(vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL) this->_expected_element("", "x");

    this->v_state_stack_.pop();
}

void positionType_pskel::sequence_0(unsigned long& state, unsigned long& count, const ::xml_schema::ro_string& ns,
                                    const ::xml_schema::ro_string& n, const ::xml_schema::ro_string* t, bool start) {
    XSD_UNUSED(t);

    switch (state) {
        case 0UL: {
            if (n == "x" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->x_parser_;

                    if (this->x_parser_) this->x_parser_->pre();
                } else {
                    if (this->x_parser_) {
                        double tmp(this->x_parser_->post_decimal());
                        this->x(tmp);
                    }

                    count = 0;
                    state = 1UL;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "x", ns, n);
                count = 0;
                state = 1UL;
                // Fall through.
            }
        }
        case 1UL: {
            if (n == "y" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->y_parser_;

                    if (this->y_parser_) this->y_parser_->pre();
                } else {
                    if (this->y_parser_) {
                        double tmp(this->y_parser_->post_decimal());
                        this->y(tmp);
                    }

                    count = 0;
                    state = 2UL;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "y", ns, n);
                count = 0;
                state = 2UL;
                // Fall through.
            }
        }
        case 2UL: {
            if (n == "z" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->z_parser_;

                    if (this->z_parser_) this->z_parser_->pre();
                } else {
                    if (this->z_parser_) {
                        double tmp(this->z_parser_->post_decimal());
                        this->z(tmp);
                    }

                    count = 0;
                    state = ~0UL;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "z", ns, n);
                count = 0;
                state = ~0UL;
                // Fall through.
            }
        }
        case ~0UL:
            break;
    }
}

// Element validation and dispatch functions for gridDimType_pskel.
//
bool gridDimType_pskel::_start_element_impl(const ::xml_schema::ro_string& ns, const ::xml_schema::ro_string& n,
                                            const ::xml_schema::ro_string* t) {
    XSD_UNUSED(t);

    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0) {
        if (this->::xml_schema::complex_content::_start_element_impl(ns, n, t))
            return true;
        else
            vd->state = 1;
    }

    while (vd->func != 0) {
        (this->*vd->func)(vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
        else
            break;
    }

    if (vd->func == 0) {
        if (vd->state != ~0UL) {
            unsigned long s = ~0UL;

            if (n == "dimx" && ns.empty()) s = 0UL;

            if (s != ~0UL) {
                vd->count++;
                vd->state = ~0UL;

                vd = vs.data + vs.size++;
                vd->func = &gridDimType_pskel::sequence_0;
                vd->state = s;
                vd->count = 0;

                this->sequence_0(vd->state, vd->count, ns, n, t, true);
            } else {
                if (vd->count < 1UL) this->_expected_element("", "dimx", ns, n);
                return false;
            }
        } else
            return false;
    }

    return true;
}

bool gridDimType_pskel::_end_element_impl(const ::xml_schema::ro_string& ns, const ::xml_schema::ro_string& n) {
    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0) {
        if (!::xml_schema::complex_content::_end_element_impl(ns, n)) assert(false);
        return true;
    }

    assert(vd.func != 0);
    (this->*vd.func)(vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL) vs.size--;

    return true;
}

void gridDimType_pskel::_pre_e_validate() {
    this->v_state_stack_.push();
    static_cast<v_state_*>(this->v_state_stack_.top())->size = 0;

    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
}

void gridDimType_pskel::_post_e_validate() {
    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0) {
        (this->*vd->func)(vd->state, vd->count, empty, empty, 0, true);
        assert(vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL) this->_expected_element("", "dimx");

    this->v_state_stack_.pop();
}

void gridDimType_pskel::sequence_0(unsigned long& state, unsigned long& count, const ::xml_schema::ro_string& ns,
                                   const ::xml_schema::ro_string& n, const ::xml_schema::ro_string* t, bool start) {
    XSD_UNUSED(t);

    switch (state) {
        case 0UL: {
            if (n == "dimx" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->dimx_parser_;

                    if (this->dimx_parser_) this->dimx_parser_->pre();
                } else {
                    if (this->dimx_parser_) {
                        long long tmp(this->dimx_parser_->post_integer());
                        this->dimx(tmp);
                    }

                    count = 0;
                    state = 1UL;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "dimx", ns, n);
                count = 0;
                state = 1UL;
                // Fall through.
            }
        }
        case 1UL: {
            if (n == "dimy" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->dimy_parser_;

                    if (this->dimy_parser_) this->dimy_parser_->pre();
                } else {
                    if (this->dimy_parser_) {
                        long long tmp(this->dimy_parser_->post_integer());
                        this->dimy(tmp);
                    }

                    count = 0;
                    state = 2UL;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "dimy", ns, n);
                count = 0;
                state = 2UL;
                // Fall through.
            }
        }
        case 2UL: {
            if (n == "dimz" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->dimz_parser_;

                    if (this->dimz_parser_) this->dimz_parser_->pre();
                } else {
                    if (this->dimz_parser_) {
                        long long tmp(this->dimz_parser_->post_integer());
                        this->dimz(tmp);
                    }

                    count = 0;
                    state = ~0UL;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "dimz", ns, n);
                count = 0;
                state = ~0UL;
                // Fall through.
            }
        }
        case ~0UL:
            break;
    }
}

// Element validation and dispatch functions for velocityType_pskel.
//
bool velocityType_pskel::_start_element_impl(const ::xml_schema::ro_string& ns, const ::xml_schema::ro_string& n,
                                             const ::xml_schema::ro_string* t) {
    XSD_UNUSED(t);

    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0) {
        if (this->::xml_schema::complex_content::_start_element_impl(ns, n, t))
            return true;
        else
            vd->state = 1;
    }

    while (vd->func != 0) {
        (this->*vd->func)(vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
        else
            break;
    }

    if (vd->func == 0) {
        if (vd->state != ~0UL) {
            unsigned long s = ~0UL;

            if (n == "x" && ns.empty()) s = 0UL;

            if (s != ~0UL) {
                vd->count++;
                vd->state = ~0UL;

                vd = vs.data + vs.size++;
                vd->func = &velocityType_pskel::sequence_0;
                vd->state = s;
                vd->count = 0;

                this->sequence_0(vd->state, vd->count, ns, n, t, true);
            } else {
                if (vd->count < 1UL) this->_expected_element("", "x", ns, n);
                return false;
            }
        } else
            return false;
    }

    return true;
}

bool velocityType_pskel::_end_element_impl(const ::xml_schema::ro_string& ns, const ::xml_schema::ro_string& n) {
    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0) {
        if (!::xml_schema::complex_content::_end_element_impl(ns, n)) assert(false);
        return true;
    }

    assert(vd.func != 0);
    (this->*vd.func)(vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL) vs.size--;

    return true;
}

void velocityType_pskel::_pre_e_validate() {
    this->v_state_stack_.push();
    static_cast<v_state_*>(this->v_state_stack_.top())->size = 0;

    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
}

void velocityType_pskel::_post_e_validate() {
    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0) {
        (this->*vd->func)(vd->state, vd->count, empty, empty, 0, true);
        assert(vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL) this->_expected_element("", "x");

    this->v_state_stack_.pop();
}

void velocityType_pskel::sequence_0(unsigned long& state, unsigned long& count, const ::xml_schema::ro_string& ns,
                                    const ::xml_schema::ro_string& n, const ::xml_schema::ro_string* t, bool start) {
    XSD_UNUSED(t);

    switch (state) {
        case 0UL: {
            if (n == "x" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->x_parser_;

                    if (this->x_parser_) this->x_parser_->pre();
                } else {
                    if (this->x_parser_) {
                        double tmp(this->x_parser_->post_decimal());
                        this->x(tmp);
                    }

                    count = 0;
                    state = 1UL;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "x", ns, n);
                count = 0;
                state = 1UL;
                // Fall through.
            }
        }
        case 1UL: {
            if (n == "y" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->y_parser_;

                    if (this->y_parser_) this->y_parser_->pre();
                } else {
                    if (this->y_parser_) {
                        double tmp(this->y_parser_->post_decimal());
                        this->y(tmp);
                    }

                    count = 0;
                    state = 2UL;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "y", ns, n);
                count = 0;
                state = 2UL;
                // Fall through.
            }
        }
        case 2UL: {
            if (n == "z" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->z_parser_;

                    if (this->z_parser_) this->z_parser_->pre();
                } else {
                    if (this->z_parser_) {
                        double tmp(this->z_parser_->post_decimal());
                        this->z(tmp);
                    }

                    count = 0;
                    state = ~0UL;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "z", ns, n);
                count = 0;
                state = ~0UL;
                // Fall through.
            }
        }
        case ~0UL:
            break;
    }
}

// Element validation and dispatch functions for configuration_pskel.
//
bool configuration_pskel::_start_element_impl(const ::xml_schema::ro_string& ns, const ::xml_schema::ro_string& n,
                                              const ::xml_schema::ro_string* t) {
    XSD_UNUSED(t);

    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0) {
        if (this->::xml_schema::complex_content::_start_element_impl(ns, n, t))
            return true;
        else
            vd->state = 1;
    }

    while (vd->func != 0) {
        (this->*vd->func)(vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
        else
            break;
    }

    if (vd->func == 0) {
        if (vd->state != ~0UL) {
            unsigned long s = ~0UL;

            if (n == "fps" && ns.empty())
                s = 0UL;
            else if (n == "video_length" && ns.empty())
                s = 1UL;
            else if (n == "delta_t" && ns.empty())
                s = 2UL;
            else if (n == "end_time" && ns.empty())
                s = 3UL;
            else if (n == "cuboid" && ns.empty())
                s = 4UL;

            if (s != ~0UL) {
                vd->count++;
                vd->state = ~0UL;

                vd = vs.data + vs.size++;
                vd->func = &configuration_pskel::sequence_0;
                vd->state = s;
                vd->count = 0;

                this->sequence_0(vd->state, vd->count, ns, n, t, true);
            } else {
                if (vd->count < 1UL) this->_expected_element("", "fps", ns, n);
                return false;
            }
        } else
            return false;
    }

    return true;
}

bool configuration_pskel::_end_element_impl(const ::xml_schema::ro_string& ns, const ::xml_schema::ro_string& n) {
    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0) {
        if (!::xml_schema::complex_content::_end_element_impl(ns, n)) assert(false);
        return true;
    }

    assert(vd.func != 0);
    (this->*vd.func)(vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL) vs.size--;

    return true;
}

void configuration_pskel::_pre_e_validate() {
    this->v_state_stack_.push();
    static_cast<v_state_*>(this->v_state_stack_.top())->size = 0;

    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
}

void configuration_pskel::_post_e_validate() {
    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0) {
        (this->*vd->func)(vd->state, vd->count, empty, empty, 0, true);
        assert(vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL) this->_expected_element("", "fps");

    this->v_state_stack_.pop();
}

void configuration_pskel::sequence_0(unsigned long& state, unsigned long& count, const ::xml_schema::ro_string& ns,
                                     const ::xml_schema::ro_string& n, const ::xml_schema::ro_string* t, bool start) {
    XSD_UNUSED(t);

    switch (state) {
        case 0UL: {
            if (n == "fps" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->fps_parser_;

                    if (this->fps_parser_) this->fps_parser_->pre();
                } else {
                    if (this->fps_parser_) {
                        long long tmp(this->fps_parser_->post_integer());
                        this->fps(tmp);
                    }

                    count = 0;
                    state = 1UL;
                }

                break;
            } else {
                assert(start);
                count = 0;
                state = 1UL;
                // Fall through.
            }
        }
        case 1UL: {
            if (n == "video_length" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->video_length_parser_;

                    if (this->video_length_parser_) this->video_length_parser_->pre();
                } else {
                    if (this->video_length_parser_) {
                        long long tmp(this->video_length_parser_->post_integer());
                        this->video_length(tmp);
                    }

                    count = 0;
                    state = 2UL;
                }

                break;
            } else {
                assert(start);
                count = 0;
                state = 2UL;
                // Fall through.
            }
        }
        case 2UL: {
            if (n == "delta_t" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->delta_t_parser_;

                    if (this->delta_t_parser_) this->delta_t_parser_->pre();
                } else {
                    if (this->delta_t_parser_) {
                        double tmp(this->delta_t_parser_->post_decimal());
                        this->delta_t(tmp);
                    }

                    count = 0;
                    state = 3UL;
                }

                break;
            } else {
                assert(start);
                count = 0;
                state = 3UL;
                // Fall through.
            }
        }
        case 3UL: {
            if (n == "end_time" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->end_time_parser_;

                    if (this->end_time_parser_) this->end_time_parser_->pre();
                } else {
                    if (this->end_time_parser_) {
                        double tmp(this->end_time_parser_->post_decimal());
                        this->end_time(tmp);
                    }

                    count = 0;
                    state = 4UL;
                }

                break;
            } else {
                assert(start);
                count = 0;
                state = 4UL;
                // Fall through.
            }
        }
        case 4UL: {
            if (n == "cuboid" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->cuboid_parser_;

                    if (this->cuboid_parser_) this->cuboid_parser_->pre();
                } else {
                    if (this->cuboid_parser_) {
                        this->cuboid_parser_->post_cuboid();
                        this->cuboid();
                    }

                    count++;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "cuboid", ns, n);
                count = 0;
                state = ~0UL;
                // Fall through.
            }
        }
        case ~0UL:
            break;
    }
}

// Element validation and dispatch functions for cuboid_pskel.
//
bool cuboid_pskel::_start_element_impl(const ::xml_schema::ro_string& ns, const ::xml_schema::ro_string& n,
                                       const ::xml_schema::ro_string* t) {
    XSD_UNUSED(t);

    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0) {
        if (this->::xml_schema::complex_content::_start_element_impl(ns, n, t))
            return true;
        else
            vd->state = 1;
    }

    while (vd->func != 0) {
        (this->*vd->func)(vd->state, vd->count, ns, n, t, true);

        vd = vs.data + (vs.size - 1);

        if (vd->state == ~0UL)
            vd = vs.data + (--vs.size - 1);
        else
            break;
    }

    if (vd->func == 0) {
        if (vd->state != ~0UL) {
            unsigned long s = ~0UL;

            if (n == "position" && ns.empty()) s = 0UL;

            if (s != ~0UL) {
                vd->count++;
                vd->state = ~0UL;

                vd = vs.data + vs.size++;
                vd->func = &cuboid_pskel::sequence_0;
                vd->state = s;
                vd->count = 0;

                this->sequence_0(vd->state, vd->count, ns, n, t, true);
            } else {
                if (vd->count < 1UL) this->_expected_element("", "position", ns, n);
                return false;
            }
        } else
            return false;
    }

    return true;
}

bool cuboid_pskel::_end_element_impl(const ::xml_schema::ro_string& ns, const ::xml_schema::ro_string& n) {
    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0) {
        if (!::xml_schema::complex_content::_end_element_impl(ns, n)) assert(false);
        return true;
    }

    assert(vd.func != 0);
    (this->*vd.func)(vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL) vs.size--;

    return true;
}

void cuboid_pskel::_pre_e_validate() {
    this->v_state_stack_.push();
    static_cast<v_state_*>(this->v_state_stack_.top())->size = 0;

    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
}

void cuboid_pskel::_post_e_validate() {
    v_state_& vs = *static_cast<v_state_*>(this->v_state_stack_.top());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0) {
        (this->*vd->func)(vd->state, vd->count, empty, empty, 0, true);
        assert(vd->state == ~0UL);
        vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL) this->_expected_element("", "position");

    this->v_state_stack_.pop();
}

void cuboid_pskel::sequence_0(unsigned long& state, unsigned long& count, const ::xml_schema::ro_string& ns,
                              const ::xml_schema::ro_string& n, const ::xml_schema::ro_string* t, bool start) {
    XSD_UNUSED(t);

    switch (state) {
        case 0UL: {
            if (n == "position" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->position_parser_;

                    if (this->position_parser_) this->position_parser_->pre();
                } else {
                    if (this->position_parser_) {
                        this->position_parser_->post_positionType();
                        this->position();
                    }

                    count = 0;
                    state = 1UL;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "position", ns, n);
                count = 0;
                state = 1UL;
                // Fall through.
            }
        }
        case 1UL: {
            if (n == "grid_dim" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->grid_dim_parser_;

                    if (this->grid_dim_parser_) this->grid_dim_parser_->pre();
                } else {
                    if (this->grid_dim_parser_) {
                        this->grid_dim_parser_->post_gridDimType();
                        this->grid_dim();
                    }

                    count = 0;
                    state = 2UL;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "grid_dim", ns, n);
                count = 0;
                state = 2UL;
                // Fall through.
            }
        }
        case 2UL: {
            if (n == "grid_spacing" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->grid_spacing_parser_;

                    if (this->grid_spacing_parser_) this->grid_spacing_parser_->pre();
                } else {
                    if (this->grid_spacing_parser_) {
                        double tmp(this->grid_spacing_parser_->post_decimal());
                        this->grid_spacing(tmp);
                    }

                    count = 0;
                    state = 3UL;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "grid_spacing", ns, n);
                count = 0;
                state = 3UL;
                // Fall through.
            }
        }
        case 3UL: {
            if (n == "temperature" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->temperature_parser_;

                    if (this->temperature_parser_) this->temperature_parser_->pre();
                } else {
                    if (this->temperature_parser_) {
                        double tmp(this->temperature_parser_->post_decimal());
                        this->temperature(tmp);
                    }

                    count = 0;
                    state = 4UL;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "temperature", ns, n);
                count = 0;
                state = 4UL;
                // Fall through.
            }
        }
        case 4UL: {
            if (n == "mass" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->mass_parser_;

                    if (this->mass_parser_) this->mass_parser_->pre();
                } else {
                    if (this->mass_parser_) {
                        double tmp(this->mass_parser_->post_decimal());
                        this->mass(tmp);
                    }

                    count = 0;
                    state = 5UL;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "mass", ns, n);
                count = 0;
                state = 5UL;
                // Fall through.
            }
        }
        case 5UL: {
            if (n == "velocity" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->velocity_parser_;

                    if (this->velocity_parser_) this->velocity_parser_->pre();
                } else {
                    if (this->velocity_parser_) {
                        this->velocity_parser_->post_velocityType();
                        this->velocity();
                    }

                    count = 0;
                    state = 6UL;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "velocity", ns, n);
                count = 0;
                state = 6UL;
                // Fall through.
            }
        }
        case 6UL: {
            if (n == "type" && ns.empty()) {
                if (start) {
                    this->::xml_schema::complex_content::context_.top().parser_ = this->type_parser_;

                    if (this->type_parser_) this->type_parser_->pre();
                } else {
                    if (this->type_parser_) {
                        long long tmp(this->type_parser_->post_integer());
                        this->type(tmp);
                    }

                    count = 0;
                    state = ~0UL;
                }

                break;
            } else {
                assert(start);
                if (count < 1UL) this->_expected_element("", "type", ns, n);
                count = 0;
                state = ~0UL;
                // Fall through.
            }
        }
        case ~0UL:
            break;
    }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.
